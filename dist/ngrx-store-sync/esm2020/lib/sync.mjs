import { Inject, Injectable } from '@angular/core';
import { createEffect } from '@ngrx/effects';
import { State } from '@ngrx/store';
import * as deepmerge_ from 'deepmerge';
import { filter, mergeMap, pairwise, startWith, tap } from 'rxjs/operators';
import { _SYNC_CONFIG } from './tokens';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/store";
import * as i2 from "@ngrx/effects";
const deepmerge = deepmerge_;
const detectDate = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
export const StorageSyncActions = {
    DUMMY: 'ngrx-store-sync/dummy',
    HYDRATED: 'ngrx-store-sync/hydrated'
};
const ignoreActions = [State.INIT, StorageSyncActions.HYDRATED];
export class StorageSyncEffects {
    constructor(_config, _store, _actions$) {
        this._config = _config;
        this._store = _store;
        this._actions$ = _actions$;
        this._hydrated = false;
        this.sync$ = createEffect(() => this._actions$.pipe(startWith({ type: StorageSyncActions.DUMMY }), tap(action => this._hydrated = this._hydrated || (action.type === StorageSyncActions.HYDRATED)), // Side-effecty :(
        filter(action => ignoreActions.indexOf(action.type) === -1), mergeMap(() => this._store.select(s => s)), pairwise(), filter(() => !this._config.rehydrate || this._hydrated), filter(([prev, curr]) => prev !== curr), mergeMap(([_, curr]) => syncStateUpdateAsync(curr, this._config.keys, this._config.storage, this._config.storageKeySerializer, this._config.removeOnUndefined, this._config.syncCondition))), { dispatch: false });
    }
}
StorageSyncEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.8", ngImport: i0, type: StorageSyncEffects, deps: [{ token: _SYNC_CONFIG }, { token: i1.Store }, { token: i2.Actions }], target: i0.ɵɵFactoryTarget.Injectable });
StorageSyncEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.8", ngImport: i0, type: StorageSyncEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.8", ngImport: i0, type: StorageSyncEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [_SYNC_CONFIG]
                }] }, { type: i1.Store }, { type: i2.Actions }]; } });
/**
 * Below this point is essentially a copy-paste of
 * https://github.com/btroncone/ngrx-store-localstorage
 * modified to interact with an asynchronous storage API
 */
// correctly parse dates from storage
export const dateReviver = (key, value) => {
    if (typeof value === 'string' && detectDate.test(value)) {
        return new Date(value);
    }
    return value;
};
const dummyReviver = (key, value) => value;
export const rehydrateApplicationStateAsync = (keys, storage, storageKeySerializer, restoreDates) => {
    return keys.reduce(async (previousPromise, curr) => {
        const state = await previousPromise;
        let key = curr;
        let reviver = restoreDates ? dateReviver : dummyReviver;
        let deserialize;
        let decrypt;
        if (typeof key === 'object') {
            key = Object.keys(key)[0];
            // use the custom reviver function
            if (typeof curr[key] === 'function') {
                reviver = curr[key];
            }
            else {
                // use custom reviver function if available
                if (curr[key].reviver) {
                    reviver = curr[key].reviver;
                }
                // use custom serialize function if available
                if (curr[key].deserialize) {
                    deserialize = curr[key].deserialize;
                }
            }
            // Ensure that encrypt and decrypt functions are both presents
            if (curr[key].encrypt && curr[key].decrypt) {
                if (typeof curr[key].encrypt === 'function' &&
                    typeof curr[key].decrypt === 'function') {
                    decrypt = curr[key].decrypt;
                }
                else {
                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);
                }
            }
            else if (curr[key].encrypt || curr[key].decrypt) {
                // Let know that one of the encryption functions is not provided
                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);
            }
        }
        return storage.get(storageKeySerializer(key)).then(slice => {
            if (slice) {
                // Use provided decrypt function
                if (decrypt) {
                    slice = decrypt(slice);
                    const isObjectRegex = new RegExp('[{\\[]');
                    if (slice === 'null' || isObjectRegex.test(slice.charAt(0))) {
                        slice = JSON.parse(slice, reviver);
                    }
                }
                return Object.assign({}, state, {
                    [key]: deserialize ? deserialize(slice) : slice
                });
            }
            return state;
        });
    }, storage.ready().then(() => ({})));
};
export const syncStateUpdateAsync = (state, keys, storage, storageKeySerializer = key => key, removeOnUndefined = false, syncCondition) => {
    try {
        if (syncCondition && syncCondition(state) !== true) {
            return Promise.resolve();
        }
    }
    catch (e) {
        // Treat TypeError as do not sync
        if (e instanceof TypeError) {
            return Promise.resolve();
        }
        throw e;
    }
    return keys.reduce(async (previousPromise, key) => {
        await previousPromise;
        let stateSlice = state[key];
        let replacer;
        let space;
        let encrypt;
        if (typeof key === 'object') {
            const name = Object.keys(key)[0];
            stateSlice = state[name];
            if (typeof stateSlice !== 'undefined' && key[name]) {
                // use serialize function if specified.
                if (key[name].serialize) {
                    stateSlice = key[name].serialize(stateSlice);
                }
                else {
                    // if serialize function is not specified keyFilter on fields if an array has been provided.
                    let keyFilter;
                    if (key[name].reduce) {
                        keyFilter = key[name];
                    }
                    else if (key[name].filter) {
                        keyFilter = key[name].filter;
                    }
                    if (keyFilter) {
                        stateSlice = keyFilter.reduce((memo, attr) => {
                            memo[attr] = stateSlice[attr];
                            return memo;
                        }, {});
                    }
                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()
                    if (key[name].encrypt && key[name].decrypt) {
                        if (typeof key[name].encrypt === 'function') {
                            encrypt = key[name].encrypt;
                        }
                    }
                    else if (key[name].encrypt || key[name].decrypt) {
                        // If one of those is not present, then let know that one is missing
                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);
                    }
                }
                /*
                  Replacer and space arguments to pass to JSON.stringify.
                  If these fields don't exist, undefined will be passed.
                 */
                replacer = key[name].replacer;
                space = key[name].space;
            }
            key = name;
        }
        if (typeof stateSlice !== 'undefined') {
            if (encrypt) {
                try {
                    // ensure that a string message is passed
                    stateSlice = encrypt(typeof stateSlice === 'string'
                        ? stateSlice
                        : JSON.stringify(stateSlice, replacer, space));
                }
                catch (e) {
                    console.warn('Unable to encrypt state:', e);
                }
            }
            return storage.set(storageKeySerializer(key), stateSlice)
                .catch(() => { throw new Error('Unable to save state to storage'); });
        }
        else if (typeof stateSlice === 'undefined' && removeOnUndefined) {
            return storage.remove(storageKeySerializer(key))
                .catch(() => { throw new Error(`Exception on removing/cleaning undefined '${key}' state`); });
        }
        return Promise.resolve();
    }, storage.ready().then(() => undefined));
};
export const storageSync = () => (reducer) => {
    return (state, action) => {
        let nextState;
        // If state arrives undefined, we need to let it through the supplied reducer
        // in order to get a complete state as defined by user
        if ((action.type === State.INIT) && !state) {
            nextState = reducer(state, action);
        }
        else {
            nextState = state;
        }
        if (action.type === StorageSyncActions.HYDRATED && action.payload) {
            const overwriteMerge = (destinationArray, sourceArray, _) => sourceArray;
            const options = {
                arrayMerge: overwriteMerge
            };
            nextState = deepmerge(nextState, action.payload, options);
        }
        return reducer(nextState, action);
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25ncngtc3RvcmUtc3luYy9zcmMvbGliL3N5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFXLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsS0FBSyxFQUFTLE1BQU0sYUFBYSxDQUFDO0FBRTNDLE9BQU8sS0FBSyxVQUFVLE1BQU0sV0FBVyxDQUFDO0FBRXhDLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLFVBQVUsQ0FBQzs7OztBQUV4QyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUM7QUFDN0IsTUFBTSxVQUFVLEdBQUcsaURBQWlELENBQUM7QUFFckUsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUc7SUFDOUIsS0FBSyxFQUFFLHVCQUF1QjtJQUM5QixRQUFRLEVBQUUsMEJBQTBCO0NBQ3ZDLENBQUM7QUFFRixNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLENBQUMsUUFBUSxDQUFDLENBQUM7QUFHaEUsTUFBTSxPQUFPLGtCQUFrQjtJQUMzQixZQUNrQyxPQUF3QixFQUM5QyxNQUFrQixFQUNsQixTQUFrQjtRQUZJLFlBQU8sR0FBUCxPQUFPLENBQWlCO1FBQzlDLFdBQU0sR0FBTixNQUFNLENBQVk7UUFDbEIsY0FBUyxHQUFULFNBQVMsQ0FBUztRQUd0QixjQUFTLEdBQUcsS0FBSyxDQUFDO1FBRXpCLFVBQUssR0FBb0IsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUM1RCxT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Q0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDdEM7YUFBTTtZQUNILFNBQVMsR0FBRyxLQUFLLENBQUM7U0FDckI7UUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssa0JBQWtCLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDL0QsTUFBTSxjQUFjLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUM7WUFDekUsTUFBTSxPQUFPLEdBQXVCO2dCQUNoQyxVQUFVLEVBQUUsY0FBYzthQUM3QixDQUFDO1lBQ0YsU0FBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztTQUM3RDtRQUVELE9BQU8sT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN0QyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQWN0aW9ucywgY3JlYXRlRWZmZWN0IH0gZnJvbSAnQG5ncngvZWZmZWN0cyc7XHJcbmltcG9ydCB7IFN0YXRlLCBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcclxuXHJcbmltcG9ydCAqIGFzIGRlZXBtZXJnZV8gZnJvbSAnZGVlcG1lcmdlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBmaWx0ZXIsIG1lcmdlTWFwLCBwYWlyd2lzZSwgc3RhcnRXaXRoLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN0b3JlU3RvcmFnZSwgU3RvcmVTeW5jQ29uZmlnIH0gZnJvbSAnLi9zeW5jLm1vZHVsZSc7XHJcbmltcG9ydCB7IF9TWU5DX0NPTkZJRyB9IGZyb20gJy4vdG9rZW5zJztcclxuXHJcbmNvbnN0IGRlZXBtZXJnZSA9IGRlZXBtZXJnZV87XHJcbmNvbnN0IGRldGVjdERhdGUgPSAvKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSkvO1xyXG5cclxuZXhwb3J0IGNvbnN0IFN0b3JhZ2VTeW5jQWN0aW9ucyA9IHtcclxuICAgIERVTU1ZOiAnbmdyeC1zdG9yZS1zeW5jL2R1bW15JyxcclxuICAgIEhZRFJBVEVEOiAnbmdyeC1zdG9yZS1zeW5jL2h5ZHJhdGVkJ1xyXG59O1xyXG5cclxuY29uc3QgaWdub3JlQWN0aW9ucyA9IFtTdGF0ZS5JTklULCBTdG9yYWdlU3luY0FjdGlvbnMuSFlEUkFURURdO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU3RvcmFnZVN5bmNFZmZlY3RzIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIEBJbmplY3QoX1NZTkNfQ09ORklHKSBwcml2YXRlIF9jb25maWc6IFN0b3JlU3luY0NvbmZpZyxcclxuICAgICAgICBwcml2YXRlIF9zdG9yZTogU3RvcmU8YW55PixcclxuICAgICAgICBwcml2YXRlIF9hY3Rpb25zJDogQWN0aW9uc1xyXG4gICAgKSB7fVxyXG5cclxuICAgIHByaXZhdGUgX2h5ZHJhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgIHN5bmMkOiBPYnNlcnZhYmxlPGFueT4gPSBjcmVhdGVFZmZlY3QoKCkgPT4gdGhpcy5fYWN0aW9ucyQucGlwZShcclxuICAgICAgICBzdGFydFdpdGgoIHsgdHlwZTogU3RvcmFnZVN5bmNBY3Rpb25zLkRVTU1ZIH0pLFxyXG4gICAgICAgIHRhcChhY3Rpb24gPT4gdGhpcy5faHlkcmF0ZWQgPSB0aGlzLl9oeWRyYXRlZCB8fCAoYWN0aW9uLnR5cGUgPT09IFN0b3JhZ2VTeW5jQWN0aW9ucy5IWURSQVRFRCkpLCAvLyBTaWRlLWVmZmVjdHkgOihcclxuICAgICAgICBmaWx0ZXIoYWN0aW9uID0+IGlnbm9yZUFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgPT09IC0xKSxcclxuICAgICAgICBtZXJnZU1hcCgoKSA9PiB0aGlzLl9zdG9yZS5zZWxlY3QocyA9PiBzKSksXHJcbiAgICAgICAgcGFpcndpc2UoKSxcclxuICAgICAgICBmaWx0ZXIoKCkgPT4gIXRoaXMuX2NvbmZpZy5yZWh5ZHJhdGUgfHwgdGhpcy5faHlkcmF0ZWQpLFxyXG4gICAgICAgIGZpbHRlcigoW3ByZXYsIGN1cnJdKSA9PiBwcmV2ICE9PSBjdXJyKSxcclxuICAgICAgICBtZXJnZU1hcCgoW18sIGN1cnJdKSA9PiBzeW5jU3RhdGVVcGRhdGVBc3luYyhcclxuICAgICAgICAgICAgY3VycixcclxuICAgICAgICAgICAgdGhpcy5fY29uZmlnLmtleXMsXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5zdG9yYWdlLFxyXG4gICAgICAgICAgICB0aGlzLl9jb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIsXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5yZW1vdmVPblVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdGhpcy5fY29uZmlnLnN5bmNDb25kaXRpb25cclxuICAgICAgICApKVxyXG4gICAgKSwgeyBkaXNwYXRjaDogZmFsc2UgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCZWxvdyB0aGlzIHBvaW50IGlzIGVzc2VudGlhbGx5IGEgY29weS1wYXN0ZSBvZlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYnRyb25jb25lL25ncngtc3RvcmUtbG9jYWxzdG9yYWdlXHJcbiAqIG1vZGlmaWVkIHRvIGludGVyYWN0IHdpdGggYW4gYXN5bmNocm9ub3VzIHN0b3JhZ2UgQVBJXHJcbiAqL1xyXG5cclxuLy8gY29ycmVjdGx5IHBhcnNlIGRhdGVzIGZyb20gc3RvcmFnZVxyXG5leHBvcnQgY29uc3QgZGF0ZVJldml2ZXIgPSAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGRldGVjdERhdGUudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG5cclxuY29uc3QgZHVtbXlSZXZpdmVyID0gKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB2YWx1ZTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWh5ZHJhdGVBcHBsaWNhdGlvblN0YXRlQXN5bmMgPSAoXHJcbiAgICBrZXlzOiBhbnlbXSxcclxuICAgIHN0b3JhZ2U6IFN0b3JlU3RvcmFnZSxcclxuICAgIHN0b3JhZ2VLZXlTZXJpYWxpemVyOiAoKGtleTogc3RyaW5nKSA9PiBzdHJpbmcpLFxyXG4gICAgcmVzdG9yZURhdGVzOiBib29sZWFuXHJcbik6IFByb21pc2U8YW55PiA9PiB7XHJcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoYXN5bmMgKHByZXZpb3VzUHJvbWlzZSwgY3VycikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgcHJldmlvdXNQcm9taXNlO1xyXG5cclxuICAgICAgICBsZXQga2V5ID0gY3VycjtcclxuICAgICAgICBsZXQgcmV2aXZlciA9IHJlc3RvcmVEYXRlcyA/IGRhdGVSZXZpdmVyIDogZHVtbXlSZXZpdmVyO1xyXG4gICAgICAgIGxldCBkZXNlcmlhbGl6ZTtcclxuICAgICAgICBsZXQgZGVjcnlwdDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGtleSA9IE9iamVjdC5rZXlzKGtleSlbMF07XHJcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VzdG9tIHJldml2ZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyW2tleV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldml2ZXIgPSBjdXJyW2tleV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHJldml2ZXIgZnVuY3Rpb24gaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycltrZXldLnJldml2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXZpdmVyID0gY3VycltrZXldLnJldml2ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHNlcmlhbGl6ZSBmdW5jdGlvbiBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyW2tleV0uZGVzZXJpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZSA9IGN1cnJba2V5XS5kZXNlcmlhbGl6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZW5jcnlwdCBhbmQgZGVjcnlwdCBmdW5jdGlvbnMgYXJlIGJvdGggcHJlc2VudHNcclxuICAgICAgICAgICAgaWYgKGN1cnJba2V5XS5lbmNyeXB0ICYmIGN1cnJba2V5XS5kZWNyeXB0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJba2V5XS5lbmNyeXB0ID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJba2V5XS5kZWNyeXB0ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ID0gY3VycltrZXldLmRlY3J5cHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFaXRoZXIgZW5jcnlwdCBvciBkZWNyeXB0IGlzIG5vdCBhIGZ1bmN0aW9uIG9uICcke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltrZXldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0nIGtleSBvYmplY3QuYFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycltrZXldLmVuY3J5cHQgfHwgY3VycltrZXldLmRlY3J5cHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIExldCBrbm93IHRoYXQgb25lIG9mIHRoZSBlbmNyeXB0aW9uIGZ1bmN0aW9ucyBpcyBub3QgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgYEVpdGhlciBlbmNyeXB0IG9yIGRlY3J5cHQgZnVuY3Rpb24gaXMgbm90IHByZXNlbnQgb24gJyR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJba2V5XVxyXG4gICAgICAgICAgICAgICAgICAgIH0nIGtleSBvYmplY3QuYFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0b3JhZ2UuZ2V0KHN0b3JhZ2VLZXlTZXJpYWxpemVyKGtleSkpLnRoZW4oc2xpY2UgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBwcm92aWRlZCBkZWNyeXB0IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVjcnlwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlID0gZGVjcnlwdChzbGljZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNPYmplY3RSZWdleCA9IG5ldyBSZWdFeHAoJ1t7XFxcXFtdJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGljZSA9PT0gJ251bGwnIHx8IGlzT2JqZWN0UmVnZXgudGVzdChzbGljZS5jaGFyQXQoMCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gSlNPTi5wYXJzZShzbGljZSwgcmV2aXZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiBkZXNlcmlhbGl6ZSA/IGRlc2VyaWFsaXplKHNsaWNlKSA6IHNsaWNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBzdG9yYWdlLnJlYWR5KCkudGhlbigoKSA9PiAoe30pKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc3luY1N0YXRlVXBkYXRlQXN5bmMgPSAoXHJcbiAgICBzdGF0ZTogYW55LFxyXG4gICAga2V5czogYW55W10sXHJcbiAgICBzdG9yYWdlOiBTdG9yZVN0b3JhZ2UsXHJcbiAgICBzdG9yYWdlS2V5U2VyaWFsaXplcjogKGtleTogc3RyaW5nKSA9PiBzdHJpbmcgPSBrZXkgPT4ga2V5LFxyXG4gICAgcmVtb3ZlT25VbmRlZmluZWQgPSBmYWxzZSxcclxuICAgIHN5bmNDb25kaXRpb24/OiAoc3RhdGU6IGFueSkgPT4gYm9vbGVhblxyXG4pOiBQcm9taXNlPHZvaWQ+ID0+ICB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChzeW5jQ29uZGl0aW9uICYmIHN5bmNDb25kaXRpb24oc3RhdGUpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoICggZSApIHtcclxuICAgICAgICAvLyBUcmVhdCBUeXBlRXJyb3IgYXMgZG8gbm90IHN5bmNcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGtleXMucmVkdWNlKCBhc3luYyAocHJldmlvdXNQcm9taXNlLCBrZXkpID0+IHtcclxuICAgICAgICBhd2FpdCBwcmV2aW91c1Byb21pc2U7XHJcblxyXG4gICAgICAgIGxldCBzdGF0ZVNsaWNlID0gc3RhdGVba2V5XTtcclxuICAgICAgICBsZXQgcmVwbGFjZXI7XHJcbiAgICAgICAgbGV0IHNwYWNlO1xyXG4gICAgICAgIGxldCBlbmNyeXB0O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IE9iamVjdC5rZXlzKGtleSlbMF07XHJcbiAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBzdGF0ZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVTbGljZSAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5W25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2Ugc2VyaWFsaXplIGZ1bmN0aW9uIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgICAgICAgIGlmIChrZXlbbmFtZV0uc2VyaWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGtleVtuYW1lXS5zZXJpYWxpemUoc3RhdGVTbGljZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNlcmlhbGl6ZSBmdW5jdGlvbiBpcyBub3Qgc3BlY2lmaWVkIGtleUZpbHRlciBvbiBmaWVsZHMgaWYgYW4gYXJyYXkgaGFzIGJlZW4gcHJvdmlkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleUZpbHRlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5W25hbWVdLnJlZHVjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlGaWx0ZXIgPSBrZXlbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlbbmFtZV0uZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUZpbHRlciA9IGtleVtuYW1lXS5maWx0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGtleUZpbHRlci5yZWR1Y2UoKG1lbW8sIGF0dHIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9bYXR0cl0gPSBzdGF0ZVNsaWNlW2F0dHJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGVuY3J5cHQgYW5kIGRlY3J5cHQgYXJlIHByZXNlbnQsIGFsc28gY2hlY2tlZCBhdCB0aGlzI3JlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlbbmFtZV0uZW5jcnlwdCAmJiBrZXlbbmFtZV0uZGVjcnlwdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleVtuYW1lXS5lbmNyeXB0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ID0ga2V5W25hbWVdLmVuY3J5cHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVtuYW1lXS5lbmNyeXB0IHx8IGtleVtuYW1lXS5kZWNyeXB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9uZSBvZiB0aG9zZSBpcyBub3QgcHJlc2VudCwgdGhlbiBsZXQga25vdyB0aGF0IG9uZSBpcyBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgRWl0aGVyIGVuY3J5cHQgb3IgZGVjcnlwdCBmdW5jdGlvbiBpcyBub3QgcHJlc2VudCBvbiAnJHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlbbmFtZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIGtleSBvYmplY3QuYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICBSZXBsYWNlciBhbmQgc3BhY2UgYXJndW1lbnRzIHRvIHBhc3MgdG8gSlNPTi5zdHJpbmdpZnkuXHJcbiAgICAgICAgICAgICAgICAgIElmIHRoZXNlIGZpZWxkcyBkb24ndCBleGlzdCwgdW5kZWZpbmVkIHdpbGwgYmUgcGFzc2VkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICByZXBsYWNlciA9IGtleVtuYW1lXS5yZXBsYWNlcjtcclxuICAgICAgICAgICAgICAgIHNwYWNlID0ga2V5W25hbWVdLnNwYWNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBrZXkgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVNsaWNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAoZW5jcnlwdCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBhIHN0cmluZyBtZXNzYWdlIGlzIHBhc3NlZFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBlbmNyeXB0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3RhdGVTbGljZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhdGVTbGljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShzdGF0ZVNsaWNlLCByZXBsYWNlciwgc3BhY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBlbmNyeXB0IHN0YXRlOicsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZS5zZXQoc3RvcmFnZUtleVNlcmlhbGl6ZXIoa2V5KSwgc3RhdGVTbGljZSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNhdmUgc3RhdGUgdG8gc3RvcmFnZScpOyB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZVNsaWNlID09PSAndW5kZWZpbmVkJyAmJiByZW1vdmVPblVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZS5yZW1vdmUoc3RvcmFnZUtleVNlcmlhbGl6ZXIoa2V5KSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IHRocm93IG5ldyBFcnJvcihgRXhjZXB0aW9uIG9uIHJlbW92aW5nL2NsZWFuaW5nIHVuZGVmaW5lZCAnJHtrZXl9JyBzdGF0ZWApOyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH0sIHN0b3JhZ2UucmVhZHkoKS50aGVuKCgpID0+IHVuZGVmaW5lZCkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2VTeW5jID0gKCkgPT4gKHJlZHVjZXI6IGFueSkgPT4ge1xyXG4gICAgcmV0dXJuIChzdGF0ZTogYW55LCBhY3Rpb246IGFueSkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0U3RhdGU7XHJcblxyXG4gICAgICAgIC8vIElmIHN0YXRlIGFycml2ZXMgdW5kZWZpbmVkLCB3ZSBuZWVkIHRvIGxldCBpdCB0aHJvdWdoIHRoZSBzdXBwbGllZCByZWR1Y2VyXHJcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZ2V0IGEgY29tcGxldGUgc3RhdGUgYXMgZGVmaW5lZCBieSB1c2VyXHJcbiAgICAgICAgaWYgKChhY3Rpb24udHlwZSA9PT0gU3RhdGUuSU5JVCkgJiYgIXN0YXRlKSB7XHJcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dFN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFN0b3JhZ2VTeW5jQWN0aW9ucy5IWURSQVRFRCAmJiBhY3Rpb24ucGF5bG9hZCkge1xyXG4gICAgICAgICAgICBjb25zdCBvdmVyd3JpdGVNZXJnZSA9IChkZXN0aW5hdGlvbkFycmF5LCBzb3VyY2VBcnJheSwgXykgPT4gc291cmNlQXJyYXk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IGRlZXBtZXJnZV8uT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGFycmF5TWVyZ2U6IG92ZXJ3cml0ZU1lcmdlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IGRlZXBtZXJnZShuZXh0U3RhdGUsIGFjdGlvbi5wYXlsb2FkLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZWR1Y2VyKG5leHRTdGF0ZSwgYWN0aW9uKTtcclxuICAgIH07XHJcbn07XHJcbiJdfQ==